#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Standard Libraries
import argparse
import hashlib
import multiprocessing
import os
import re
import signal
import sys
import time
import traceback
import urllib.request

MIN = (3, 3)
if not sys.version_info >= MIN:
    raise EnvironmentError(
        f"Python version too low, required at least {'.'.join(map(str, MIN))}")

sigs = []

class TimeoutException(Exception):   # Custom exception class
    pass

def timeout_handler(signum, frame):   # Custom signal handler
    raise TimeoutException

signal.signal(signal.SIGALRM, timeout_handler)

def load_signatures():
    file_path = "signatures.db"
    with open(file_path, "r") as f:
        for line in f:
            sigs.append(re.compile(line))

def handle_sigint(sig, frame):
    print("\nExiting\n")
    raise SystemExit()

def scan_file(file_path, sigs, verbose, output_file, debug):
    try:
        print(f"Scanning file: {file_path}")
        start_time = time.time()
        with open(file_path, "rb") as f:
            content = f.read()
        content = content.decode(errors='ignore')
        for sig in sigs:
            sig_start_time = time.time()
            signal.alarm(10)
            try:
                match = sig.search(content)
            except TimeoutException:
                print(f"Skipping regex {sig.pattern} due to timeout")
                with open('regex-fail.log', 'a') as log_file:
                    log_file.write(f"Skipping regex {sig.pattern} due to timeout\n")               
                continue
            else:
                signal.alarm(0)
            sig_elapsed_time = time.time() - sig_start_time
            if match:
                pattern = sig.pattern
                message = f"Found signature {pattern} in file: {file_path}" if verbose else f"Found signature in file: {file_path}"
                print(message)
                with open(output_file, "a") as out_f:
                    out_f.write(f"{file_path}\n")
                return True
            if debug:
                print(f"Benchmark - Regex: {sig.pattern}, Time: {sig_elapsed_time} seconds")
        if verbose:
            print(f"No match found in file: {file_path}")
        if debug:    
            elapsed_time = time.time() - start_time
            print(f"Benchmark - File: {file_path}, Total Time: {elapsed_time} seconds")
        return False
    except KeyboardInterrupt:
        print('Interrupted')
    except Exception as e:
        traceback.print_exc()
        return False

def scan_file_parallel(file_path, sigs, verbose, output_file, debug):
    try:
        return scan_file(file_path, sigs, verbose, output_file, debug)
    except KeyboardInterrupt:
        print('Interrupted')
    except Exception as e:
        traceback.print_exc()
        return False

def scan_directory(directory_path, extension, args):
    output_file = args.file if args.file else "found_files.txt"
    malware_count = 0
    if args.individual:
        if not os.path.isfile(directory_path):
            raise ValueError(f"{directory_path} is not a valid file")
        print(f"Scanning file {directory_path} for signatures")
        try:
            if scan_file(directory_path, sigs, args.verbose, output_file, args.debug):
                malware_count += 1
        except Exception as e:
            traceback.print_exc()
        print(f"Found {malware_count} instances of malware in {directory_path}")
    else:
        print(f"Scanning directory {directory_path} and files with extension {extension}")
        file_paths = []
        for root, _, files in os.walk(directory_path):
            for file_name in files:
                if file_name.endswith(extension):
                    file_path = os.path.join(root, file_name)
                    if not os.path.islink(file_path):
                        file_paths.append(file_path)

        max_processes = max(1, multiprocessing.cpu_count() // 2)
        with multiprocessing.Pool(processes=max_processes) as pool:
            results = pool.starmap(
                scan_file_parallel, [(file_path, sigs, args.verbose, output_file, args.debug) for file_path in file_paths])                
        malware_count = sum(results)
        print(f"Found {malware_count} files with malware.")

#---------------------------------------------------------------------------------------------------------#
version = "2.0.1"
sigs = []
signatures = len(sigs)
autor = "Alberto Ferrer"
email = "albertof@barrahome.org"
url = "https://www.barrahome.org"
#---------------------------------------------------------------------------------------------------------#

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Scan a directory for files with suspicious signatures")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-i", "--individual", help="Path to individual file to scan")
    group.add_argument("-d", "--directory", help="Path to directory to scan")
    parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
    parser.add_argument("-f", "--file", help="output file name")
    parser.add_argument("-e", "--extension", default="php", help="File extension to scan for")
    parser.add_argument("--debug", help="Enable debug mode (Show benchmark info)", action="store_true")
    args = parser.parse_args()
    signal.signal(signal.SIGINT, handle_sigint)
    load_signatures()
    signatures = len(sigs)
    banner = f"""
-----------------------------------------------------------------------------------
Malware Finder {version}
Signatures Loaded: {signatures}
-----------------------------------------------------------------------------------
Autor: {autor}
Email: {email}
URL: {url}
"""
    print(banner)
    if args.individual:
        scan_file(args.individual, sigs, args.verbose, args.file, args.debug)
    else:
        scan_directory(args.directory, args.extension, args)